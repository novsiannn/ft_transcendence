import { handleModalError } from "../../elements";
import { tournamentPlayerData, tournamentPlayerProfiles, updateRankedProfilesPositions } from "./playersProfiles";
import { API_URL, store} from "../../store/store";
import {
    IGameState,
    getCurrentGameState,
    socket,  
    movePaddle, 
    leaveGame,
    onGameUpdate,
    onGameFinished,
    clearGameCallbacks,
    timerCountdown,
} from "../../websockets/client";
import { rankedWinnerData, gameOverModalCreator } from "./gameModal";
import { 
    setupRankedListeners, 
    updatePlayerProfiles, 
    setupInitialReadyButtonsVisibility, 
    setupButtonDelegation, 
    startRankedGame as startRankedGameLogic,
    rankedGameStatus,
    cancelRankedMatch,
    getCurrentGame 
} from "./ratingGame";

// Основа игры - универсальные функции для всех режимов
export function handleGame(mainWrapper: HTMLDivElement | undefined) {

    setupMultiplayerSocketHandlers();
    const scoreInfo = document.querySelector("#score-info");
    const gameBoard = document.getElementById("game-board") as HTMLCanvasElement;
    let currentReadyButtonHandler: ((e: Event) => void) | null = null;
    
    let intervalID: ReturnType<typeof setInterval>;
    let isGameRunning = false;
    let isWaitingForStart = false;
    let gameStartedOnce = false;

    // Игровые переменные для режимов
    let gameMode: 'local' | 'multiplayer' | null = null;
    let currentGameId: string | null = null;

    mainWrapper!.id = "game-container";
    mainWrapper!.classList.add("h-screen", "flex", "flex-col", "gap-2.5", "justify-center", "items-center");
    const context = gameBoard?.getContext("2d");

    const gameBoardColor = window.getComputedStyle(gameBoard).backgroundColor;
    const firstPaddleColor = "white";
    const secondPaddleColor = "white";

    let currentGameState = getCurrentGameState();
    
    // const moveFirstPaddleKey = {
    //     up: "w",
    //     down: "s"
    // }
    
    // const moveSecondPaddleKey = {
    //     up: "arrowup",
    //     down: "arrowdown"
    // }

    const keys = new Set<string>();

    let firstPlayerScore = currentGameState.paddles['1'].score;
    let secondPlayerScore = currentGameState.paddles['2'].score || 0;

    const firstPaddleInitial = {
        x: currentGameState.paddles['1'].x,
        y: currentGameState.paddles['1'].y,
    }
    
    const secondPaddleInitial = {
        x: currentGameState.paddles['2'].x,
        y: currentGameState.paddles['2'].y,
    }

    let firstPaddle = { ...firstPaddleInitial };
    let secondPaddle = { ...secondPaddleInitial };

    const paddleEffects = {
        glowSize: 15,      
        glowIntensity: 3,    
        glowColor: 'white',  
        baseColor: 'white'   
    }

    // const ballInitial = {
    //     x: gameBoardWidth / 2,
    //     y: gameBoardHeight / 2,
    // }
    
    
    let ball = currentGameState.ball;

    const ballDirection = {
        x: currentGameState.ball.direction.x,
        y: currentGameState.ball?.direction.y,
    }

    let profilesLastUpdate: string = "";

    function checkIfProfilesNeedUpdate(gameState: IGameState): boolean {
        const playerIds = Object.keys(gameState.paddles);
        if (playerIds.length < 2) return false;
        
        // Создаем ключ состояния для отслеживания изменений
        const currentState = `${playerIds[0]}-${gameState.paddles[playerIds[0]].x}-${playerIds[1]}-${gameState.paddles[playerIds[1]].x}`;
        
        if (profilesLastUpdate !== currentState) {
            profilesLastUpdate = currentState;
            return true;
        }
        
        return false;
    }

    function renderGame(gameState: IGameState) {
        // Обновляем позиции профилей только если они еще не синхронизированы с позициями ракеток
        const shouldUpdateProfiles = checkIfProfilesNeedUpdate(gameState);
        if (shouldUpdateProfiles) {
            updateRankedProfilesPositions(gameState);
        }
        
        // Получаем ID игроков динамически
        const playerIds = Object.keys(gameState.paddles);
        
        if (playerIds.length >= 2) {
            // Обновляем локальные переменные (если нужны для других функций)
            firstPlayerScore = gameState.paddles[playerIds[0]].score;
            secondPlayerScore = gameState.paddles[playerIds[1]].score;
        }

        // Обновляем мяч
        ball.x = gameState.ball.x;
        ball.y = gameState.ball.y;

        // Отрисовываем (очищаем canvas перед отрисовкой)
        context!.clearRect(0, 0, gameState.settings.boardWidth, gameState.settings.boardHeight);
        
        drawBoard(gameState);
        drawPaddles(gameState);
        drawBall(gameState);
        updateScore(gameState);
    }

    function drawBoard(gameState: IGameState) {
        context!.fillStyle = gameBoardColor;
        context!.fillRect(0, 0,gameState.settings.boardWidth,gameState.settings.boardHeight);
    }

    function drawPaddle(paddleX: number, paddleY: number, paddleColor: string, gameState: IGameState) {
        const { glowSize, glowIntensity } = paddleEffects;
        const radius = gameState.settings.paddleWidth / 2;
    
        for(let i = 0; i < glowIntensity; i++) {
            context!.beginPath();
            context!.shadowColor = paddleColor;
            context!.shadowBlur = glowSize + (i * 5);
            context!.shadowOffsetX = 0;
            context!.shadowOffsetY = 0;
            context!.fillStyle = 'rgba(255, 255, 255, 0.2)';
            
            roundRect(
                context!,
                paddleX - i,
                paddleY - i,
                gameState.settings.paddleWidth + (i * 2),
                gameState.settings.paddleHeight + (i * 2),
                radius
            );
            context!.fill();
        }
    
        context!.beginPath();
        context!.shadowColor = 'transparent';
        context!.fillStyle = paddleColor;
        
        roundRect(
            context!,
            paddleX,
            paddleY,
            gameState.settings.paddleWidth,
            gameState.settings.paddleHeight,
            radius
        );
        context!.fill();
    
        context!.shadowColor = 'transparent';
        context!.shadowBlur = 0;
    }
    
    function roundRect(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        width: number,
        height: number,
        radius: number
    ) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
    }

function drawPaddles(gameState: IGameState) {
    const currentUserId = store.getUser().id;
    const playerIds = Object.keys(gameState.paddles);
    
    if (playerIds.length >= 2) {
        const player1Id = parseInt(playerIds[0]);
        const player2Id = parseInt(playerIds[1]);
        
        const player1X = gameState.paddles[playerIds[0]].x;
        const player2X = gameState.paddles[playerIds[1]].x;
        
        // Определяем, кто слева, кто справа
        let leftPlayerId, rightPlayerId, leftPaddle, rightPaddle;
        
        if (player1X < player2X) {
            // Player1 слева, Player2 справа
            leftPlayerId = player1Id;
            rightPlayerId = player2Id;
            leftPaddle = gameState.paddles[playerIds[0]];
            rightPaddle = gameState.paddles[playerIds[1]];
        } else {
            // Player2 слева, Player1 справа
            leftPlayerId = player2Id;
            rightPlayerId = player1Id;
            leftPaddle = gameState.paddles[playerIds[1]];
            rightPaddle = gameState.paddles[playerIds[0]];
        }
        let leftColor = "white";
        let rightColor = "white";
        // Цвета: текущий игрок - синий, противник - белый
        if(gameState.isRunning){
            leftColor = (leftPlayerId === currentUserId) ? "#3B82F6" : "white";
            rightColor = (rightPlayerId === currentUserId) ? "#3B82F6" : "white";
        }
        
        // Отрисовываем ракетки
        drawPaddle(leftPaddle.x, leftPaddle.y, leftColor, gameState);
        drawPaddle(rightPaddle.x, rightPaddle.y, rightColor, gameState);
    }
}

    function drawBall(gameState: IGameState) {
        for(let i = 0; i < 3; i++) {
            context!.beginPath();
            context!.shadowColor = 'white';
            context!.shadowBlur = 20 + (i * 5);
            context!.shadowOffsetX = 0;
            context!.shadowOffsetY = 0;
            context!.fillStyle = 'rgba(255, 255, 255, 1)';
            context!.arc(gameState.ball.x,gameState.ball.y, gameState.settings.ballRadius + i, 0, Math.PI * 2);
            context!.fill();
        }
        
        context!.beginPath();
        context!.shadowColor = 'transparent';
        context!.arc(gameState.ball.x, gameState.ball.y, gameState.settings.ballRadius, 0, Math.PI * 2);
        context!.fill();
        
        context!.shadowColor = 'transparent';
        context!.shadowBlur = 0;
    }

    function updateScore(gameState: IGameState) {

        const currentUserId = store.getUser().id;
    
        // Находим ID игроков
        const playerIds = Object.keys(gameState.paddles);

        let leftPlayerScore = 0;
        let rightPlayerScore = 0;
        
        // Определяем, кто слева, кто справа по позиции X
        const player1Id = playerIds[0];
        const player2Id = playerIds[1];
        
        const player1X = gameState.paddles[player1Id].x;
        const player2X = gameState.paddles[player2Id].x;
        
        // Игрок с меньшим X слева, с большим X справа
        if (player1X < player2X) {
            leftPlayerScore = gameState.paddles[player1Id].score;
            rightPlayerScore = gameState.paddles[player2Id].score;
        } else {
            leftPlayerScore = gameState.paddles[player2Id].score;
            rightPlayerScore = gameState.paddles[player1Id].score;
        }

        scoreInfo!.textContent = `${leftPlayerScore} : ${rightPlayerScore}`;
    }

    // РЕЖИМЫ ИГРЫ
    function initTournamentGame() {
        gameMode = 'local';
        cleanupCurrentGame();
        
        scoreInfo!.classList.remove('hidden');
        
        // Start local tournament game directly
        setTimeout(() => {
            // startActualGame();
        }, 1000);
    }



    function resetMatchmakingButtons() {
        cancelRankedMatchBtn?.classList.add("hidden");
        startRankedMatchBtn?.classList.remove("hidden");
    }

    let currentGame: any = null; // Добавьте эту переменную в начало функции handleGame

function getCurrentGame() {
    return currentGame;
}

    function setupReadyButtonsVisibility(isCurrentUserPlayer1: boolean, isCurrentUserPlayer2: boolean) {
        // Не устанавливаем видимость кнопок здесь, это будет делаться в updateRankedProfilesPositions
        // после правильного определения позиций игроков
    }

function setupButtonDelegation(gameId: string) {
    const currentUserId = store.getUser().id;
    const rankedProfiles = document.querySelector("#rankedProfiles");
    
    // ✅ ВАЖНО: Полностью пересоздаем элемент, чтобы удалить ВСЕ обработчики
    if (rankedProfiles && rankedProfiles.parentNode) {
        const newRankedProfiles = rankedProfiles.cloneNode(true) as HTMLElement;
        rankedProfiles.parentNode.replaceChild(newRankedProfiles, rankedProfiles);
        
        // Обновляем ссылку на новый элемент
        const updatedRankedProfiles = document.querySelector("#rankedProfiles");
        
        const handleReadyButtonClick = (e: Event) => {
            const target = e.target as HTMLElement;
            
            if (target.id === "playerOneReadyBtn" || target.id === "playerTwoReadyBtn") {
                e.stopPropagation();
                
                let game = getCurrentGame();
                const isCurrentUserPlayer1 = currentUserId === game?.player1Id;
                const isCurrentUserPlayer2 = currentUserId === game?.player2Id;
                
                const isPlayer1Button = target.id === "playerOneReadyBtn";
                const isPlayer2Button = target.id === "playerTwoReadyBtn";
                
                if ((isPlayer1Button && !isCurrentUserPlayer1) || (isPlayer2Button && !isCurrentUserPlayer2)) {
                    return;
                }
                
                target.classList.add("opacity-50");
                target.classList.add("cursor-not-allowed");
                target.classList.remove("hover:bg-blue-600");
                target.setAttribute("disabled", "true");
                target.textContent = "Ready!";
                
                console.log(`Emitting game:join with gameId: ${gameId}`);
                socket?.emit('game:join', gameId);
                console.log("SETUP BUTTON DELEGATION GAME DATA : ", game);
            }
        };

        // Привязываем к новому элементу
        updatedRankedProfiles?.addEventListener("click", handleReadyButtonClick);
        currentReadyButtonHandler = handleReadyButtonClick;
    }
}

function setupKeyboardHandlers() {
    // Убираем старые обработчики, чтобы избежать дублирования
    window.removeEventListener("keydown", handleKeyDown);
    window.removeEventListener("keyup", handleKeyUp);
    
    // Добавляем новые
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    
}

function setupMultiplayerSocketHandlers() {
    // Очищаем старые обработчики
    // clearGameCallbacks();
timerCountdown((data) => {
    const seconds = data.seconds;
    
    const countdownElement = document.getElementById("countdown");
    countdownElement?.classList.remove("hidden");
        countdownElement!.textContent = seconds.toString();
    
    setTimeout(() => {
        countdownElement?.classList.add("hidden");
        scoreInfo?.classList.remove("hidden");
    }, 5000);
    
});

    onGameUpdate((gameState) => {
        renderGame(gameState);
    });

    onGameFinished((result) => {
        console.log("Game finished:", result);
        handleGameOver(result);
    });


}

    function initMultiplayerGame(gameId: string) {
        const rankedProfilesContainer = document.querySelector('#rankedProfiles');
        gameMode = 'multiplayer';
        currentGameId = gameId;
        currentGameState = getCurrentGameState();
        setupMultiplayerSocketHandlers();
        setupKeyboardHandlers();
        
        socket?.emit('mm:leave', gameId);
        renderGame(currentGameState);
        
        

        rankedProfilesContainer?.classList.remove("hidden");
        // initGame();
    }

function cleanupCurrentGame() {
    if (currentGameId) {
        leaveGame(currentGameId);
    }
    
    // ✅ Полная очистка всех обработчиков
    const rankedProfiles = document.querySelector("#rankedProfiles");
    if (rankedProfiles && rankedProfiles.parentNode) {
        const newElement = rankedProfiles.cloneNode(true) as HTMLElement;
        rankedProfiles.parentNode.replaceChild(newElement, rankedProfiles);
    }
    
    currentReadyButtonHandler = null;
    clearGameCallbacks();
    
    currentGameId = null;
    gameMode = null;
    isGameRunning = false;
}

function handleGameOver(result?: any) {
    const gameOverModalContainer = document.querySelector("#gameOverModal");
    // clearInterval(intervalID);
        isGameRunning = false;
        isWaitingForStart = true;
        gameStartedOnce = false;
        scoreInfo!.classList.add('hidden');
        
        if (result?.winner) {
            rankedWinnerData.id = result.winner;
        }
        if(gameOverModalContainer)
        {
            gameOverModalContainer!.innerHTML = gameOverModalCreator(result.winner);
        }
        
        gameOverModalContainer!.classList.remove('hidden');
        gameOverModalContainer!.classList.add('flex');

        
        // Очищаем игровой обработчик
        setTimeout(() => {
        cleanupCurrentGame();
    }, 100);
}

function handleKeyDown(ev: KeyboardEvent) {
    const key = ev.key.toLowerCase();
    keys.add(key);
    
    // Для мультиплеера отправляем на сервер
    if (gameMode === 'multiplayer' && currentGameId) {
        if (key === 'w') {
            movePaddle(currentGameId, 'up');
            console.log("W PRESSED");
            console.log("CURENT GAME ID", currentGameId);
        } else if (key === 's') {
            movePaddle(currentGameId, 'down');
            console.log("S PRESSED");
            console.log("CURENT GAME ID", currentGameId);
        }
    } else {
    }
}
    
    function handleKeyUp(ev: KeyboardEvent) {
        const key = ev.key.toLowerCase();
        keys.delete(key);
    }



    // function setupInitialState(gameState: IGameState) {
    //     isGameRunning = false;
    //     isWaitingForStart = true;
    
    //     firstPaddle = { ...firstPaddleInitial };
    //     secondPaddle = { ...secondPaddleInitial };
    //     firstPaddleTargetY = firstPaddleInitial.y;
    //     secondPaddleTargetY = secondPaddleInitial.y;

    //     drawBoard(gameState);
    //     drawPaddles(gameState);
    //     // updateScore(gameState);
    //     setBallDirection();
    //     drawBall(gameState);
    //     scoreInfo!.classList.add('hidden');
    
    //     // if (!gameStartedOnce && gameMode !== 'local' && gameMode !== 'multiplayer') {
    //     //     window.removeEventListener("keyup", startGame);
    //     //     window.addEventListener("keyup", startGame, { once: true });
    //     // }
    // }
    
    function initGame() {
        initRankedGameMode();
        onGameUpdate((gameState) => {
            renderGame(gameState);
        });
    }

    async function updateAllStoreUsers(){
        try{
            const updatedUsers = await store.getAllUsersRequest();
            if (updatedUsers) {
                store.setAllUsers(updatedUsers);
            }
        }
        catch(error){
            // Handle error
        }
    }

    // Инициализация рейтингового режима
    function initRankedGameMode() {
        const preGameModal = document.querySelector("#preGameModal");
        const rankedGameModal = document.querySelector("#rankedGameModal");
        const startRankedMatchBtn = document.querySelector("#startRankedMatchBtn");
        const cancelRankedMatchBtn = document.querySelector("#cancelRankedMatchBtn");
        const rankedTimer = document.querySelector("#rankedTimer");
        const spinerDiv = document.querySelector("#spinerDiv");
        const rankedProfiles = document.querySelector("#rankedProfiles");
        const btmBtn = document.querySelector("#backToMenuBtn");
        const rankedMatchBtn = document.querySelector("#rankedMatchBtn");

        let rankedTimerInterval: ReturnType<typeof setInterval> | null = null;
        let rankedTimerValue = 0;

        rankedMatchBtn?.addEventListener("click", async (e) => {
            e.stopPropagation();
            preGameModal?.classList.add("hidden");
            rankedGameModal?.classList.remove("hidden");
            rankedGameModal?.classList.add("flex");
        });

        function formatTimer(seconds: number): string {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min}:${sec.toString().padStart(2, "0")}`;
        }

        function timer() {
            rankedTimerValue = 0;
            if (rankedTimer) rankedTimer.textContent = formatTimer(rankedTimerValue);
            if (rankedTimerInterval) clearInterval(rankedTimerInterval);

            rankedTimerInterval = setInterval(() => {
                rankedTimerValue++;
                if (rankedTimer) rankedTimer.textContent = formatTimer(rankedTimerValue);
            }, 1000);
        }

        // Инициализируем слушатели рейтинговой игры
        const rankedListenersSetup = () => setupRankedListeners(
            rankedGameModal,
            preGameModal,
            spinerDiv,
            rankedProfiles,
            initMultiplayerGame,
            updatePlayerProfiles,
            setupButtonDelegation,
            resetMatchmakingButtons,
            updateAllStoreUsers
        );

        startRankedMatchBtn?.addEventListener("click", async (e) => {
            e.stopPropagation();
            btmBtn?.setAttribute("disabled", "true");
            
            await startRankedGameLogic(
                spinerDiv,
                timer,
                startRankedMatchBtn,
                cancelRankedMatchBtn,
                rankedGameModal,
                rankedTimerInterval,
                initMultiplayerGame,
                updateAllStoreUsers,
                rankedListenersSetup
            );
        });

        cancelRankedMatchBtn?.addEventListener("click", async (e) => {
            e.stopPropagation();
            await cancelRankedMatch(
                rankedTimerInterval,
                spinerDiv,
                cancelRankedMatchBtn,
                startRankedMatchBtn,
                btmBtn
            );
        });

        // Проверяем статус рейтинговой игры при загрузке
        rankedGameStatus(
            preGameModal,
            rankedGameModal,
            startRankedMatchBtn,
            spinerDiv,
            cancelRankedMatchBtn
        );
    }
    renderGame(currentGameState);

    // TOURNAMENT PART
    const preGameModal = document.querySelector("#preGameModal");
    const tournamentDropdownMenu = document.querySelector("#tournamentDropdownMenu");
    const tournamentDropdownButton = document.querySelector("#tournamentDropdownButton");
    
    tournamentDropdownButton?.addEventListener("click", (e) => {
        e.stopPropagation();
        tournamentDropdownMenu?.classList.toggle("hidden");
    });

    const tournamentModal = document.querySelector("#tournamentModal");
    const fourPlayersGameBtn = document.querySelector("#fourPlayersGameBtn");
    const clickSubmitNicknameBtn = document.querySelector("#submitNicknameBtn");
    const playerNickname = document.querySelector("#playerNickname") as HTMLInputElement;
    const tournamentProfiles = document.querySelector("#tournamentProfiles");
    const selectAvatar = document.querySelector("#selectedAvatar");
    const tournamentBracket = document.querySelector("#tournamentBracket");
    
    clickSubmitNicknameBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        handleSubmitNickname();
    });

    playerNickname?.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            handleSubmitNickname();
        }
    });
    
    function handleSubmitNickname(){
        if (playerNickname.value.includes(" ") || playerNickname.value === "") {
            handleModalError("Please enter a nickname");
            return;
        }
        else if (playerNickname.value.length > 10) {
            handleModalError("Nickname is too long");
            playerNickname.value = "";
            return;
        }
        tournamentPlayerData.nicknames.push(playerNickname.value);
        tournamentPlayerData.avatars.set(playerNickname.value, (selectAvatar as HTMLImageElement)!.src);
        playerNickname.value = "";
        
        console.log(tournamentPlayerData.nicknames);
        if(tournamentPlayerData.nicknames.length === 4) {
            tournamentModal?.classList.add("hidden");
            tournamentModal?.classList.remove("flex");
            tournamentBracket?.classList.remove("hidden");
            createTournamentNet();
        }
    }

    fourPlayersGameBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        tournamentDropdownMenu?.classList.toggle("hidden");
        preGameModal?.classList.add("hidden");
        tournamentModal?.classList.remove("hidden");
        tournamentModal?.classList.add("flex");
        tournamentProfiles?.classList.remove("hidden");
        fourPlayersTournament();
    });

    function createTournamentNet() {
        let num;
        while(true){
            num = Math.floor(Math.random() * 4);
            if (!tournamentPlayerData.tournamentNet.includes(num)) {
                tournamentPlayerData.tournamentNet.push(num);
                if(tournamentPlayerData.tournamentNet.length === 4) {
                    break;
                }
                continue;
            }		
        }
        if (tournamentProfiles) {
            tournamentProfiles.innerHTML = tournamentPlayerProfiles();
        }
        
        // Инициализируем турнирную игру
        initTournamentGame();
    }

    function fourPlayersTournament(){
        // Логика турнира будет обрабатываться в createTournamentNet
    }

    const avatarSelectBtn = document.querySelector("#avatarSelectBtn");
    const avatarDropdown = document.querySelector("#avatarDropdown");
    const selectedAvatar = document.querySelector("#selectedAvatar");

    avatarSelectBtn?.addEventListener('click', () => {
        avatarDropdown?.classList.toggle('hidden');
    });

    avatarDropdown?.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        const btn = target.closest('button[data-avatar]');
        if (btn) {
            const avatar = btn.getAttribute('data-avatar');
            if (avatar && selectedAvatar) {
                (selectedAvatar as HTMLImageElement).src = avatar;
                avatarDropdown.classList.add('hidden');
            }
        }
    });
    
    // FRIENDS MATCH PART
    const friendsDropDown = document.querySelector("#friendsDropDown");
    const friendSelectBtn = document.querySelector("#friendSelectBtn");
    const createFriendsMatchBtn = document.querySelector("#createFriendsMatchBtn");
    const friendsMatchModal = document.querySelector("#friendsMatchModal");
    const gameModeDropdownBtn = document.querySelector("#gameModeDropdownBtn");
    const gameDropdownMenu = document.querySelector("#gameDropdownMenu");

    gameModeDropdownBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        gameDropdownMenu?.classList.toggle("hidden");
    });

    createFriendsMatchBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        gameDropdownMenu?.classList.toggle("hidden");
        preGameModal?.classList.add("hidden");
        friendsMatchModal?.classList.remove("hidden");
        friendsMatchModal?.classList.add("flex");
    });

    friendSelectBtn?.addEventListener('click', () => {
        friendsDropDown?.classList.toggle('hidden');
        getFriendsList();
    });

    function getFriendsList() {
        const friends = store.getAllFriends();
        const friendsList = document.querySelector("#friendsDropDown");
        const selectedFriend = document.querySelector("#selectedFriend");
        const selectedFriendBtn = document.querySelector("#friendSelectBtn");

        if (friendsList) {
            friendsList.innerHTML = "";

            friends.forEach((friend) => {
                const friendBtn = document.createElement("button");
                friendBtn.className = "flex items-center p-2 hover:bg-gray-100";
                friendBtn.setAttribute("data-avatar", friend.avatar);
                friendBtn.innerHTML = `
                    <img src="${API_URL}${friend.avatar}" class="w-8 h-8 rounded-full mr-2" alt="avatar" /> ${friend.username}
                `;
                friendBtn.addEventListener("click", () => {
                    if (selectedFriend) {
                        (selectedFriend as HTMLImageElement).src = API_URL + friend.avatar;
                        const btn = document.getElementById("friendSelectBtn");
                        const span = btn?.querySelector("span");
                        if (span) {
                            span.textContent = friend.username;
                        }
                    }
                    friendsList.classList.add("hidden");
                });
                friendsList.appendChild(friendBtn);
            });
        }
    }

    // RANKED GAME PART
    const rankedMatchBtn = document.querySelector("#rankedMatchBtn");
    const rankedGameModal = document.querySelector("#rankedGameModal");
    // const rankedGameBtn = document.querySelector("#rankedGameBtn");
    const startRankedMatchBtn = document.querySelector("#startRankedMatchBtn");
    const cancelRankedMatchBtn = document.querySelector("#cancelRankedMatchBtn");
    const rankedTimer = document.querySelector("#rankedTimer");
    const spinerDiv = document.querySelector("#spinerDiv");
    const rankedProfiles = document.querySelector("#rankedProfiles");
    const btmBtn = document.querySelector("#backToMenuBtn")


    let rankedTimerInterval: ReturnType<typeof setInterval> | null = null;
    let rankedTimerValue = 0;

    rankedMatchBtn?.addEventListener("click", async (e) => {
        e.stopPropagation();
        preGameModal?.classList.add("hidden");
        rankedGameModal?.classList.remove("hidden");
        rankedGameModal?.classList.add("flex");
        
    });

    function formatTimer(seconds: number): string {
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        return `${min}:${sec.toString().padStart(2, "0")}`;
    }

    async function startRankedGame()
    {
        try {

            setupRankedListeners();

            const response = await instanceAPI.post("/game/matchmaking", {
                body: { },
            });
            
            if(response.status === 200) {
                spinerDiv?.classList.remove("hidden");
                spinerDiv?.classList.add("flex");
                timer();
				socket?.emit('game:joinQueue');
                startRankedMatchBtn?.classList.add("hidden");
                cancelRankedMatchBtn?.classList.remove("hidden");
            }
            
            if(response.status === 201) {
                const userResponseData = response.data as {
                    message: string,
                    game: {
                        id: number,
                        player1Id: number,
                        player2Id: number,
                        status: string,
                        gameMode: string
                    }
                };

                // Инициализируем мультиплеерную игру
                const gameId = userResponseData.game.id.toString();
                await updateAllStoreUsers();
                initMultiplayerGame(gameId);
                
                // store.getUserRequest();
                updatePlayerProfiles(userResponseData);
                setupButtonDelegation(gameId);
                console.log("START RANKED GAME", gameId);
                
                rankedGameModal?.classList.add("hidden");

                
                if (rankedTimerInterval) clearInterval(rankedTimerInterval);
            }

        } catch (error) {
            
            console.error('Error starting ranked match:', error);
        }
    }

    startRankedMatchBtn?.addEventListener("click", async (e) => {
        e.stopPropagation();
        btmBtn?.setAttribute("disabled", "true");
        startRankedGame();
    });

    cancelRankedMatchBtn?.addEventListener("click", async (e) => {
        e.stopPropagation();
        try {
            const response = await instanceAPI.delete("/game/matchmaking");
            if(response.status === 200) {
                if (rankedTimerInterval) clearInterval(rankedTimerInterval);
                spinerDiv?.classList.add("hidden");
                spinerDiv?.classList.remove("flex");
				socket?.emit('game:leaveQueue');
                console.log("Match Canceled", response.status);
                cancelRankedMatchBtn?.classList.add("hidden");
                startRankedMatchBtn?.classList.remove("hidden");
                btmBtn?.removeAttribute("disabled");
            }
        } catch (error) {
            console.error('Error canceling ranked match:', error);
        }
    });

    function timer() {
        rankedTimerValue = 0;
        if (rankedTimer) rankedTimer.textContent = formatTimer(rankedTimerValue);
        if (rankedTimerInterval) clearInterval(rankedTimerInterval);

        rankedTimerInterval = setInterval(() => {
            rankedTimerValue++;
            if (rankedTimer) rankedTimer.textContent = formatTimer(rankedTimerValue);
        }, 1000);
    }

    async function rankedGameStatus() {
        try{
            const response = await instanceAPI.get("/game/matchmaking/status");
            let responseData = response.data as {inQueue: true}
            if(responseData.inQueue) {
                preGameModal?.classList.add("hidden");
                rankedGameModal?.classList.remove("hidden");
                rankedGameModal?.classList.add("flex");
                startRankedMatchBtn?.classList.add("hidden");
                spinerDiv?.classList.remove("invisible");
                cancelRankedMatchBtn?.classList.remove("hidden");
            } else {
                preGameModal?.classList.remove("hidden");
                preGameModal?.classList.add("flex");
            }
        } catch (error) {
            console.error('Error checking ranked game status:', error);
        }
    }
    
    //DELETE LATER DEVELOPMENT BUTTON
    const rankedDeleteGameBtn = document.querySelector("#rankedDeleteGameBtn");
        rankedDeleteGameBtn?.addEventListener("click", async (e) => {
        e.stopPropagation();
        try {
            const gameToDelete = `/game/1`;
            console.log("DELETE ADRESS", gameToDelete)
            const response = await instanceAPI.delete(gameToDelete);
            if(response.status === 200) {
               console.log("Game Deleted", response.status);
            }
        } catch (error) {
            console.error('Error deleting game:', error);
        }
    });

    document.addEventListener("click", async (e) =>{
        const target = e.target as HTMLElement;
        if(target.id === "backToMenuBtn")
        {
            
            e.stopPropagation();
            const gameOverModal = document.querySelector("#gameOverModal");
            if(!rankedGameModal?.classList.contains("hidden"))
            {
                spinerDiv?.classList.add("hidden");
                rankedGameModal?.classList.add("hidden");
                preGameModal?.classList.remove("hidden");
            }
            if(!gameOverModal?.classList.contains("hidden"))
            {
                btmBtn?.removeAttribute("disabled");
                spinerDiv?.classList.add("hidden");
                gameOverModal?.classList.add("hidden");
                preGameModal?.classList.remove("hidden");
            }
        }
    });
    // In case more PLAYAGAIN buttons - REWORK!!!
document.addEventListener("click", (e) => {
    const target = e.target as HTMLElement;
    if (target.id === "rankedPlayAgainBtn") {
        e.stopPropagation();
        
        // ✅ Простая очистка
        // if (currentGameId) {
        //     leaveGame(currentGameId);
        // }
        
        // ✅ Переустанавливаем listeners
        // reinitializeGameSocketHandlers();
        
        // Скрываем модалки и запускаем новую игру
        const gameOverModal = document.querySelector("#gameOverModal");
        gameOverModal?.classList.add("hidden");
        gameOverModal?.classList.remove("flex");

        rankedGameModal?.classList.remove("hidden");
        rankedGameModal?.classList.add("flex");
        
        startRankedGame();
    }
});

   async function updateAllStoreUsers(){
        try{
            const updatedUsers = await store.getAllUsersRequest();
            if (updatedUsers) {
                store.setAllUsers(updatedUsers);
            }
        }
        catch(error){

        }
    }


    initGame();
}